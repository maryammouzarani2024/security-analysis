/*  This file is part of Fuzzgrind.
 *  Copyright (C) 2009 Gabriel Campana
 *  
 *  Based heavily on Flayer by redpig@dataspill.org
 *  Copyright (C) 2006,2007 Will Drewry <redpig@dataspill.org>
 *  Some portions copyright (C) 2007 Google Inc.
 * 
 *  Based heavily on MemCheck by jseward@acm.org
 *  MemCheck: Copyright (C) 2000-2007 Julian Seward
 *  jseward@acm.org
 * 
 * 
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU General Public License as
 *  published by the Free Software Foundation; either version 2 of the
 *  License, or (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307, USA.
 *  
 *  The GNU General Public License is contained in the file LICENCE.
 */


#include "pub_tool_basics.h"
#include "pub_tool_tooliface.h"
#include "pub_tool_libcassert.h"
#include "pub_tool_libcprint.h"
#include "pub_tool_debuginfo.h"
#include "pub_tool_libcbase.h"
#include "pub_tool_options.h"
#include "pub_tool_machine.h"
#include "pub_tool_vkiscnums.h"
#include "pub_tool_mallocfree.h"
#include "fz.h"


Dep deptmp[MAX_DEP];
Dep depreg[MAX_DEP];
Dep depaddr8[MAX_DEP];
Dep depaddr16[MAX_DEP];
Dep depaddr32[MAX_DEP];
UInt depaddr8_count = 0;
UInt depaddr16_count = 0;
UInt depaddr32_count = 0;
struct Heap_Vars *heapHead;

#define fz_MALLOC_REDZONE_SZB 16 /* let's say */
#define FZ_DEBUG
//#undef FZ_DEBUG

int AddToHeap(Addr addr, int len) //adds the new address and length. The list is sorted increasing based on address.
{
	struct Heap_Vars *add = (struct Heap_Vars*)VG_(malloc)("HeapVars", sizeof(struct Heap_Vars));

	add->addr = addr;
	add->len = len;
	add->next=NULL;
	struct Heap_Vars *itr , *itrprev ;
	itr = NULL;
	itrprev = NULL;
	if (heapHead == NULL)
	{
		VG_(printf)("adding address %x with len %d \n", addr, len);
		heapHead = add;
		return 0;
	}
	itr = heapHead;
	if (itr->next== NULL){// there is only one node in the list
		if (add->addr > itr->addr){
			itr->next=add;
			return 0;
		}
		if (add->addr < itr->addr){
			add->next= itr;
			return 0;
		}
		if (add->addr == itr->addr)
				{
					VG_(printf)("the same addr is added!!!\n");
					return -1;
				}
	}
	while (itr != NULL)// there are more than one node in the list
	{

		if (add->addr > itr->addr)
		{
			itrprev = itr;
			itr = itr->next;
			continue;
		}
		if (add->addr < itr->addr)
		{
			if (itrprev== NULL){ // If the new node is smaller than the first node in the list
				add->next=itr;
				VG_(printf)("adding address %x with len %d \n", addr, len);
				break;
			}
			itrprev->next = add;
			add->next = itr;
			break;
		}
		if (add->addr == itr->addr)
		{
			VG_(printf)("the same addr is added!!!\n");
			return -1;
		}
	}

	return (itr == NULL) ? -1 : 0 ;

}

int DeleteFromHeap(Addr addr)
{
	struct Heap_Vars *itr , *itrprev ;
	itr = NULL;
	itrprev = NULL;
	if (heapHead == NULL)
	{
		return 0;
	}
	itr = heapHead;

	while (itr != NULL)
	{
		if (addr == itr-> addr)
		{
			if (itrprev == NULL) // delete 1st element
			{

				heapHead = itr->next;
				return 10;
			}
			else
			{
				itrprev->next = itr->next;
				return itr->len;
			}
		}
		itrprev = itr;
		itr = itr->next;
	}

	return 0;
}

static void fz_fini(Int exitcode)
{

}


static void fz_post_clo_init(void) {
	VG_(printf)("post called\n");  
	FZ_(setup_tainted_map)();
	
}

/*------------------------------------------------------------*/
/*--- Syscall event handlers                                ---*/
/*------------------------------------------------------------*/
void* fz_new_block ( ThreadId tid, Addr p, SizeT szB, SizeT alignB, Bool is_zeroed)
{
   ExeContext* ec;
   // Allocate and zero if necessary
      p = (Addr)VG_(cli_malloc)( alignB, szB );
      if (!p) {
         return NULL;
      }
       VG_(memset)((void*)p, 0, szB);  
		   AddToHeap((Addr)p , szB);
	//VG_(printf)("the address is %x and the size is %d \n",p, szB);
   return (void*)p;
}


static void* fz_malloc( ThreadId tid, SizeT n ) {

   void *mem;
   mem = NULL;
   if (n<0) {
      return NULL;
   } else {
	   mem = fz_new_block ( tid, 0, n,4096, False);
	   if (mem != NULL)
	   {
		   AddToHeap((Addr)mem , n);
	   }
      return mem;
   }
}

static void* fz_builtin_new ( ThreadId tid, SizeT n ) {

	   void *mem;
	   mem = NULL;
	   if (n<0) {
	      return NULL;
	   } else {
		   mem = fz_new_block ( tid, 0, n,4096, False);
		   if (mem != NULL)
		   {
			   AddToHeap((Addr)mem , n);
		   }
	      return mem;
	   }
}
static void* fz_builtin_vec_new ( ThreadId tid, SizeT n ) {
	// in the future we should consider the difference between vector and simple malloc
	   void *mem;
	   mem = NULL;
	   if (n<0) {
	      return NULL;
	   } else {
		   mem = fz_new_block ( tid, 0, n,4096, False);
		   if (mem != NULL)
		   {
			   AddToHeap((Addr)mem , n);
		   }
	      return mem;
	   }
}
static void* fz_memalign ( ThreadId tid, SizeT align, SizeT n ) {
   VG_(printf)("hhhhhhhhhhhhhhhhh\n");
   return NULL;
}
static void* fz_calloc ( ThreadId tid, SizeT nmemb, SizeT size1 ) {
   VG_(printf)("hhhhhhhhhhhhhhhhh\n");
   return NULL;
}

static void fz_free ( ThreadId tid, void* p ) {
	int szB;
	szB=0;
	szB=DeleteFromHeap(p);
	 VG_(memset)((void*)p, -1, szB);

}
static void fz_builtin_delete ( ThreadId tid, void* p ) {
   VG_(printf)("delete built in \n");
   return NULL;
}
static void fz_delete ( ThreadId tid, void* p ) {
   VG_(printf)("delete\n");
   return NULL;

}
static void fz_builtin_vec_delete ( ThreadId tid, void* p ) {
      VG_(printf)("vec delete\n");
   return NULL;
}
static SizeT fz_malloc_usable_size ( ThreadId tid, void* p )
{
   VG_(printf)("hhhhhhhhhhhhhhhhh\n");
   return NULL;
}

static void* fz_realloc ( ThreadId tid, void* payloadV, SizeT new_size )
{
   VG_(printf)("hhhhhhhhhhhhhhhhh\n");
   return NULL;
}


static void fz_pre_syscall(ThreadId tid, UInt syscallno, UWord* args, UInt nArgs) {
}


static void fz_post_syscall(ThreadId tid, UInt syscallno, UWord* args, UInt nArgs, SysRes res) {
  switch (syscallno) {
    case __NR_read:
      FZ_(syscall_read)(tid, args, nArgs, res);
      break;
    case __NR_write:
      FZ_(syscall_write)(tid, args, nArgs, res);
      break;
    case __NR_open:
      FZ_(syscall_open)(tid, args, nArgs, res);
      break;
    case __NR_close:
      FZ_(syscall_close)(tid, args, nArgs, res);
      break;
    case __NR_lseek:
#ifdef __NR__llseek
    case __NR__llseek:
#endif
      FZ_(syscall_lseek)(tid, args, nArgs, res);
      break;
#ifdef __NR_mmap
    case __NR_mmap:
#endif
#ifdef __NR_mmap2
    case __NR_mmap2:
#endif
      FZ_(syscall_mmap2)(tid, args, nArgs, res);
      break;
    case __NR_munmap:
      FZ_(syscall_munmap)(tid, args, nArgs, res);
      break;
    default:
      break;
  }
}

/*------------------------------------------------------------*/
/*--- Command line args                                    ---*/
/*------------------------------------------------------------*/

static Char   FZ_(default_file_filter)[]      = "";
Char*         FZ_(clo_file_filter)            = FZ_(default_file_filter);
Bool          FZ_(clo_taint_file)             = False;
Bool          FZ_(clo_taint_stdin)            = False;
Bool          FZ_(verbose)                    = False;

static Bool fz_process_cmd_line_options(Char* arg) {
    if VG_STR_CLO(arg, "--file-filter", FZ_(clo_file_filter)) {}
    else if VG_BOOL_CLO(arg, "--taint-stdin", FZ_(clo_taint_stdin)) {}
    else if VG_BOOL_CLO(arg, "--taint-file", FZ_(clo_taint_file)) {}
    //else if VG_BOOL_CLO(arg, "--taint-network", FL_(clo_taint_network)) {}
    else if VG_BOOL_CLO(arg, "--show-ir", FZ_(verbose)) {}
    
    return True;
}

static void fz_print_usage(void) {  
   VG_(printf)(

"    --taint-stdin=no|yes             enables stdin tainting [no]\n"
"    --taint-file=no|yes              enables file tainting [no]\n"
//"    --taint-network=no|yes           enables network tainting [no]\n"
"    --file-filter=/path/prefix       enforces tainting on any files under\n"
"                                     the given prefix. []\n"
"    --show-ir=no|yes                 show intermediate representation statements [no]\n"
   );
}

static void fz_print_debug_usage(void) {  
}


static void fz_pre_clo_init(void)
{
    heapHead= NULL;
	UInt i;
    VG_(details_name)            ("Fuzzgrind");
    VG_(details_version)         (NULL);
    VG_(details_description)     ("a super fuzzer");
    VG_(details_copyright_author)(
      "Copyright (C) 2008-2009, ("__DATE__", "__TIME__") by Gabriel Campana.");
    VG_(details_bug_reports_to)  (VG_BUGS_TO);
    VG_(details_avg_translation_sizeB) ( 640 );


    VG_(basic_tool_funcs)        (fz_post_clo_init,
                                  fz_instrument,
                                  fz_fini);

    VG_(needs_command_line_options)(fz_process_cmd_line_options,
                                    fz_print_usage,
                                    fz_print_debug_usage);
    
    VG_(needs_syscall_wrapper)   ( fz_pre_syscall,
                                   fz_post_syscall );
//   VG_(needs_malloc_replacement2)  (fz_malloc);
      VG_(needs_malloc_replacement) (fz_malloc,
                                   fz_builtin_new,
                                   fz_builtin_vec_new,
                                   fz_memalign,
                                   fz_calloc,
                                   fz_free,
                                   fz_builtin_delete,
                                   fz_builtin_vec_delete,
                                   fz_realloc,
                                   fz_malloc_usable_size, 
                                   fz_MALLOC_REDZONE_SZB);

    VG_(memset)(deptmp, 0, sizeof(deptmp));
    VG_(memset)(depreg, 0, sizeof(deptmp));
    VG_(memset)(depaddr8, 0, sizeof(depaddr8));
    VG_(memset)(depaddr16, 0, sizeof(depaddr16));
    VG_(memset)(depaddr32, 0, sizeof(depaddr32));
    
    for (i = 0; i < MAX_DEP; i++) {
        deptmp[i].cons = deptmp[i].buf;
        deptmp[i].cons[0] = '\x00';
        depreg[i].cons = depreg[i].buf;
        depreg[i].cons[0] = '\x00';
        depaddr8[i].cons = depaddr8[i].buf;
        depaddr16[i].cons = depaddr16[i].buf;
        depaddr32[i].cons = depaddr32[i].buf;
        deptmp[i].cons_size = XXX_MAX_BUF;
        depreg[i].cons_size = XXX_MAX_BUF;
        depaddr8[i].cons_size = XXX_MAX_BUF;
        depaddr16[i].cons_size = XXX_MAX_BUF;
        depaddr32[i].cons_size = XXX_MAX_BUF;
    }
}

VG_DETERMINE_INTERFACE_VERSION(fz_pre_clo_init)
